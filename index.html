<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Convection Lab - Fluid Dynamics</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&family=Roboto+Mono:wght@500&display=swap" rel="stylesheet">
    <style>
        * {
            -webkit-tap-highlight-color: transparent;
        }
        body {
            font-family: 'Fredoka', sans-serif;
            overscroll-behavior: none;
        }
        .font-mono {
            font-family: 'Roboto Mono', monospace;
        }
        
        .bg-grid {
            background-color: #f8fafc;
            background-image: linear-gradient(rgba(0, 0, 0, 0.05) 1px, transparent 1px),
            linear-gradient(90deg, rgba(0, 0, 0, 0.05) 1px, transparent 1px);
            background-size: 30px 30px;
        }

        #simCanvas {
            touch-action: none;
        }

        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 28px;
            width: 28px;
            border-radius: 50%;
            background: #f59e0b;
            border: 3px solid #fff;
            margin-top: -11px;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 8px;
            cursor: pointer;
            background: #cbd5e1;
            border-radius: 4px;
        }
        
        .btn-glow {
            transition: all 0.2s ease;
        }
        .btn-glow:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body class="bg-grid text-gray-800 min-h-screen flex flex-col">

    <!-- Header -->
    <header class="bg-white/90 backdrop-blur border-b border-gray-200 p-4 sticky top-0 z-30 shadow-sm">
        <div class="max-w-5xl mx-auto flex justify-between items-center">
            <div class="flex items-center gap-3">
                <div class="w-10 h-10 bg-gradient-to-br from-blue-500 to-cyan-600 rounded-full flex items-center justify-center shadow-md shadow-blue-500/30">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z" />
                    </svg>
                </div>
                <div>
                    <h1 class="text-xl md:text-2xl font-bold text-gray-900 tracking-wide">Convection Lab</h1>
                </div>
            </div>
            <div class="bg-gray-100 px-3 py-2 rounded-xl border border-gray-200 flex items-center gap-2 shadow-inner">
                <span class="hidden md:inline text-xs text-gray-500 uppercase font-bold">Timer</span>
                <div id="timerDisplay" class="text-2xl md:text-3xl font-mono font-bold text-blue-600 min-w-[80px] text-right">00.0s</div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-grow flex flex-col items-center p-4 gap-6 w-full max-w-5xl mx-auto">
        
        <!-- Simulation Canvas Container -->
        <div class="relative w-full">
            <div class="relative bg-white rounded-2xl shadow-xl border border-gray-300 overflow-hidden w-full aspect-[4/3] md:aspect-[2/1]">
                <canvas id="simCanvas" class="w-full h-full block cursor-crosshair touch-none"></canvas>
                
                <!-- Sensor Tooltip -->
                <div id="sensor-tooltip" class="absolute hidden bg-white/95 backdrop-blur-md border border-gray-200 px-4 py-3 rounded-xl text-sm pointer-events-none shadow-xl transform -translate-x-1/2 -translate-y-full mt-[-15px] z-20 min-w-[100px] text-center">
                    <div class="flex flex-col items-center">
                        <span class="text-gray-500 text-[10px] uppercase tracking-wider font-bold mb-1">Temperature</span>
                        <div class="flex items-baseline gap-1">
                            <span id="tooltip-temp" class="text-3xl font-mono font-bold text-gray-900">--</span>
                            <span class="text-gray-500 font-bold">¬∞C</span>
                        </div>
                    </div>
                    <div class="absolute bottom-0 left-1/2 transform -translate-x-1/2 translate-y-full w-0 h-0 border-l-[8px] border-l-transparent border-r-[8px] border-r-transparent border-t-[8px] border-t-white filter drop-shadow-sm"></div>
                </div>

                <!-- Beaker Graphics -->
                <div class="absolute inset-0 pointer-events-none border-x-4 border-b-4 border-gray-300/50 rounded-b-3xl m-4 mt-0 z-10"></div>
                
                <!-- Flame -->
                <div class="absolute left-1/2 bottom-0 w-24 h-24 transform -translate-x-1/2 translate-y-2 pointer-events-none flex justify-center items-end z-0">
                    <div id="flame" class="w-12 h-20 bg-gradient-to-t from-orange-500 via-yellow-400 to-transparent rounded-[50%] opacity-0 transition-opacity duration-300 blur-sm"></div>
                </div>
            </div>
            
            <div id="instructions" class="absolute top-4 right-4 bg-blue-100 border border-blue-300 text-blue-800 px-4 py-2 rounded-lg text-sm backdrop-blur pointer-events-none shadow-md animate-pulse">
                üëÜ Touch water to measure temp!
            </div>
        </div>

        <!-- Controls -->
        <div class="w-full grid grid-cols-1 md:grid-cols-12 gap-4 pb-8">
            
            <!-- Playback -->
            <div class="md:col-span-5 bg-white p-4 rounded-2xl border border-gray-200 shadow-sm">
                <h2 class="text-xs font-bold text-gray-500 uppercase tracking-widest mb-4">Experiment Controls</h2>
                <div class="flex gap-3 mb-5">
                    <button id="btnStart" class="btn-glow flex-1 bg-gradient-to-r from-emerald-500 to-green-600 text-white font-bold py-3 px-4 rounded-xl shadow-md flex items-center justify-center gap-2">
                        <span>‚ñ∂</span> Start Heating
                    </button>
                    <button id="btnReset" class="btn-glow flex-1 bg-gradient-to-r from-rose-500 to-red-600 text-white font-bold py-3 px-4 rounded-xl shadow-md flex items-center justify-center gap-2">
                        <span>‚Ü∫</span> Reset
                    </button>
                </div>
                <div class="bg-gray-50 rounded-xl p-3 border border-gray-200">
                    <div class="flex items-center justify-between text-sm mb-3">
                        <span class="text-blue-700 font-bold">üî• Flame Intensity</span>
                        <span class="text-xs text-gray-500 font-bold">100%</span>
                    </div>
                    <input type="range" id="heatInput" min="0" max="100" value="100" class="w-full">
                </div>
            </div>

            <!-- View Options -->
            <div class="md:col-span-7 bg-white p-4 rounded-2xl border border-gray-200 shadow-sm">
                <h2 class="text-xs font-bold text-gray-500 uppercase tracking-widest mb-4">Visualization Mode</h2>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
                    <label class="cursor-pointer">
                        <input type="radio" name="viewMode" value="crystal" checked class="peer hidden">
                        <div class="h-full bg-gray-50 peer-checked:bg-purple-50 peer-checked:border-purple-400 border border-gray-200 rounded-xl p-3 flex flex-col items-center justify-center gap-2 transition-all shadow-sm">
                            <div class="w-8 h-8 rounded-full bg-purple-600 flex items-center justify-center text-white text-xs font-bold">K</div>
                            <span class="text-xs font-bold text-gray-700 text-center">Purple Crystal</span>
                        </div>
                    </label>
                    <label class="cursor-pointer">
                        <input type="radio" name="viewMode" value="particles" class="peer hidden">
                        <div class="h-full bg-gray-50 peer-checked:bg-blue-50 peer-checked:border-blue-400 border border-gray-200 rounded-xl p-3 flex flex-col items-center justify-center gap-2 transition-all shadow-sm">
                            <div class="w-8 h-8 rounded-full bg-blue-500 flex items-center justify-center text-white text-xs font-bold">‚óè</div>
                            <span class="text-xs font-bold text-gray-700 text-center">Density (Particles)</span>
                        </div>
                    </label>
                    <label class="cursor-pointer">
                        <input type="radio" name="viewMode" value="vectors" class="peer hidden">
                        <div class="h-full bg-gray-50 peer-checked:bg-green-50 peer-checked:border-green-400 border border-gray-200 rounded-xl p-3 flex flex-col items-center justify-center gap-2 transition-all shadow-sm">
                            <div class="w-8 h-8 rounded-full bg-green-500 flex items-center justify-center text-white text-xs font-bold">‚Üó</div>
                            <span class="text-xs font-bold text-gray-700 text-center">Currents (Arrows)</span>
                        </div>
                    </label>
                </div>
            </div>
        </div>
    </main>

    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('sensor-tooltip');
        const toolTemp = document.getElementById('tooltip-temp');
        
        // --- Physics State ---
        const state = {
            running: false,
            time: 0,
            viewMode: 'crystal',
            heatPower: 100,
            particles: [], // For Crystal/Particle modes
            vectors: [],   // For Vector mode
            grid: []       // Temperature grid
        };

        const GRID_ROWS = 20;
        const GRID_COLS = 30;
        let cellWidth, cellHeight;

        // Initialize Temperature Grid
        function initGrid() {
            state.grid = [];
            for (let r = 0; r < GRID_ROWS; r++) {
                let row = [];
                for (let c = 0; c < GRID_COLS; c++) {
                    row.push(25); // Start at 25¬∞C
                }
                state.grid.push(row);
            }
        }

        // Initialize Particles
        function initParticles() {
            state.particles = [];
            const numParticles = 300;
            
            for (let i = 0; i < numParticles; i++) {
                // Start clustered at bottom center for crystal mode, spread for others
                const isCrystal = state.viewMode === 'crystal';
                
                state.particles.push({
                    x: isCrystal ? 0.5 + (Math.random()-0.5)*0.1 : Math.random(), // Normalized 0-1
                    y: isCrystal ? 0.95 : Math.random(), // Normalized 0-1
                    vx: 0,
                    vy: 0,
                    age: 0, // For fading trail in crystal mode
                    id: Math.random() // Unique ID
                });
            }
        }

        function resize() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
            cellWidth = canvas.width / GRID_COLS;
            cellHeight = canvas.height / GRID_ROWS;
        }

        // --- Physics Engine ---
        function updatePhysics() {
            if (!state.running) return;

            state.time += 0.05;
            document.getElementById('timerDisplay').textContent = state.time.toFixed(1) + 's';

            // 1. Update Temperature Grid (Heat Source at Bottom Center)
            const heatColStart = Math.floor(GRID_COLS * 0.4);
            const heatColEnd = Math.floor(GRID_COLS * 0.6);
            
            // Apply heat to bottom row center
            for (let c = heatColStart; c < heatColEnd; c++) {
                state.grid[GRID_ROWS - 1][c] += (state.heatPower / 100) * 2.5; 
            }

            // Simple Heat Diffusion & Convection Approximation
            let newGrid = JSON.parse(JSON.stringify(state.grid)); // Deep copy
            
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    let t = state.grid[r][c];
                    
                    // Diffusion (Heat spreads to neighbors)
                    let neighbors = 0;
                    let sum = 0;
                    if (r > 0) { sum += state.grid[r-1][c]; neighbors++; }
                    if (r < GRID_ROWS - 1) { sum += state.grid[r+1][c]; neighbors++; }
                    if (c > 0) { sum += state.grid[r][c-1]; neighbors++; }
                    if (c < GRID_COLS - 1) { sum += state.grid[r][c+1]; neighbors++; }
                    
                    // Convection Logic (Hot rises)
                    // If cell below is hotter, exchange heat faster
                    let convectionFactor = 0;
                    if (r < GRID_ROWS - 1) {
                        if (state.grid[r+1][c] > t) {
                            convectionFactor = (state.grid[r+1][c] - t) * 0.2; // Heat rises
                        }
                    }

                    // Surface cooling
                    let cooling = 0.05; // Loss to walls
                    if (r === 0) cooling = 0.2; // Surface cooling

                    let avg = sum / neighbors;
                    newGrid[r][c] = t + (avg - t) * 0.1 + convectionFactor - cooling;
                    
                    // Clamp
                    if (newGrid[r][c] < 25) newGrid[r][c] = 25;
                    if (newGrid[r][c] > 100) newGrid[r][c] = 100;
                }
            }
            state.grid = newGrid;

            // 2. Update Particles (Lagrangian movement based on Vector Field)
            state.particles.forEach(p => {
                // Determine forces based on position
                let fx = 0;
                let fy = 0;

                // Simple Convection Loop Vector Field
                // Center: Up
                // Top: Out
                // Sides: Down
                // Bottom: In
                
                const dx = p.x - 0.5; // Dist from center (-0.5 to 0.5)
                const dy = p.y - 0.5; // Dist from middle (-0.5 to 0.5)

                // Upward force in middle channel
                if (Math.abs(dx) < 0.2) {
                    fy -= 0.002 * (state.heatPower/100); // Reduced from 0.005 for slower flow
                } 
                // Downward force at sides
                else if (Math.abs(dx) > 0.3) {
                    fy += 0.0012 * (state.heatPower/100); // Reduced from 0.003
                }

                // Outward push at top
                if (p.y < 0.2) {
                    fx += Math.sign(dx) * 0.002 * (state.heatPower/100); // Reduced from 0.005
                }
                // Inward pull at bottom
                if (p.y > 0.8) {
                    fx -= Math.sign(dx) * 0.002 * (state.heatPower/100); // Reduced from 0.005
                }

                // Turbulence
                fx += (Math.random() - 0.5) * 0.001; // Reduced turbulence slightly
                fy += (Math.random() - 0.5) * 0.001;

                p.vx += fx;
                p.vy += fy;

                // Damping
                p.vx *= 0.95;
                p.vy *= 0.95;

                p.x += p.vx;
                p.y += p.vy;

                // Boundaries
                if (p.x < 0.05) { p.x = 0.05; p.vx *= -0.5; }
                if (p.x > 0.95) { p.x = 0.95; p.vx *= -0.5; }
                if (p.y < 0.05) { p.y = 0.05; p.vy *= -0.5; }
                if (p.y > 0.95) { p.y = 0.95; p.vy = 0; } // Floor hits
            });
            
            // Crystal Mode: Respawn particles at bottom if they settle or get stuck for too long
            if (state.viewMode === 'crystal' && Math.random() < 0.05 && state.heatPower > 0) {
                state.particles.push({
                    x: 0.5 + (Math.random()-0.5)*0.1,
                    y: 0.95,
                    vx: 0, vy: 0, age: 0
                });
                if (state.particles.length > 500) state.particles.shift(); // Keep count manageable
            }
        }

        // --- Render ---
        function draw() {
            // Clear
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // --- Water Visuals ---
            const waterLevel = 15; // Water starts 15px from top
            
            // Water Gradient (Texture/Depth)
            const gradient = ctx.createLinearGradient(0, waterLevel, 0, canvas.height);
            gradient.addColorStop(0, 'rgba(224, 242, 254, 0.8)');   // Light surface
            gradient.addColorStop(1, 'rgba(186, 230, 253, 0.95)');  // Deeper blue bottom
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, waterLevel, canvas.width, canvas.height - waterLevel);

            // Water Surface Line
            ctx.beginPath();
            ctx.moveTo(0, waterLevel);
            ctx.lineTo(canvas.width, waterLevel);
            ctx.strokeStyle = '#0ea5e9'; // Defined surface edge
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw Container Walls (Beaker Rim)
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 5;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);

            // Draw Heat Map (Optional: subtle overlay)
            // Can be too noisy, keeping it clean for now.
            
            // VIEW MODES
            if (state.viewMode === 'crystal') {
                ctx.globalCompositeOperation = 'multiply';
                state.particles.forEach(p => {
                    const px = p.x * canvas.width;
                    const py = p.y * canvas.height;
                    
                    ctx.beginPath();
                    ctx.arc(px, py, 4, 0, Math.PI*2);
                    ctx.fillStyle = `rgba(147, 51, 234, 0.6)`; // Purple
                    ctx.fill();
                });
                ctx.globalCompositeOperation = 'source-over';
                
                // Draw dissolving crystal pile at bottom
                ctx.beginPath();
                ctx.arc(canvas.width/2, canvas.height - 10, 15, Math.PI, 0);
                ctx.fillStyle = '#7e22ce';
                ctx.fill();
            } 
            else if (state.viewMode === 'particles') {
                state.particles.forEach(p => {
                    const px = p.x * canvas.width;
                    const py = p.y * canvas.height;
                    
                    // Color based on height (temp proxy)
                    // Bottom (Hot) = Red, Top (Cold) = Blue
                    const tempFactor = 1 - p.y; 
                    const r = Math.floor(255 * tempFactor);
                    const b = Math.floor(255 * (1 - tempFactor));
                    
                    ctx.beginPath();
                    // Draw larger circle for hot (expansion), smaller for cold
                    const rSize = 3 + (tempFactor * 3);
                    ctx.arc(px, py, rSize, 0, Math.PI*2);
                    ctx.fillStyle = `rgba(${r}, 50, ${b}, 0.8)`;
                    ctx.fill();
                });
            }
            else if (state.viewMode === 'vectors') {
                // Draw Grid of arrows
                const arrowSpacing = 50;
                // Only draw arrows below water level
                for(let x = arrowSpacing/2; x < canvas.width; x += arrowSpacing) {
                    for(let y = Math.max(arrowSpacing/2, waterLevel + 20); y < canvas.height; y += arrowSpacing) {
                        const nx = x / canvas.width;
                        const ny = y / canvas.height;
                        
                        // Calculate vector field at this point (same logic as physics)
                        let vx = 0, vy = 0;
                        const dx = nx - 0.5;
                        
                        if (Math.abs(dx) < 0.2) vy = -1;
                        else if (Math.abs(dx) > 0.3) vy = 0.6;
                        
                        if (ny < 0.2) vx = Math.sign(dx) * 1;
                        if (ny > 0.8) vx = -Math.sign(dx) * 1;
                        
                        // Scale by heat
                        if (!state.running) { vx=0; vy=0; }
                        
                        // Draw Arrow
                        if (vx !== 0 || vy !== 0) {
                            const endX = x + vx*20;
                            const endY = y + vy*20;
                            
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(endX, endY);
                            ctx.strokeStyle = '#ef4444'; // Red arrows
                            ctx.lineWidth = 2;
                            ctx.stroke();
                            
                            // Arrowhead (Triangle)
                            const headLen = 6; 
                            const angle = Math.atan2(vy, vx);
                            
                            ctx.beginPath();
                            ctx.moveTo(endX, endY);
                            ctx.lineTo(endX - headLen * Math.cos(angle - Math.PI / 6), endY - headLen * Math.sin(angle - Math.PI / 6));
                            ctx.lineTo(endX - headLen * Math.cos(angle + Math.PI / 6), endY - headLen * Math.sin(angle + Math.PI / 6));
                            ctx.closePath();
                            ctx.fillStyle = '#ef4444';
                            ctx.fill();
                        }
                    }
                }
            }
            
            // (Moved container walls drawing to top to be behind/around water)
        }

        // --- Loop ---
        function loop() {
            updatePhysics();
            draw();
            animationId = requestAnimationFrame(loop);
        }

        // --- Interaction ---
        const btnStart = document.getElementById('btnStart');
        const btnReset = document.getElementById('btnReset');
        const heatInput = document.getElementById('heatInput');
        const flame = document.getElementById('flame');
        
        btnStart.addEventListener('click', toggleSim);
        btnStart.addEventListener('touchstart', toggleSim, {passive: false});

        function toggleSim(e) {
            if(e.cancelable) e.preventDefault();
            if(!state.running) {
                state.running = true;
                btnStart.innerHTML = "<span>‚è∏</span> Pause";
                btnStart.classList.replace('from-emerald-500', 'from-amber-500');
                btnStart.classList.replace('to-green-600', 'to-orange-500');
                flame.style.opacity = state.heatPower / 100;
                document.getElementById('instructions').style.opacity = '0';
            } else {
                state.running = false;
                btnStart.innerHTML = "<span>‚ñ∂</span> Resume";
                btnStart.classList.replace('from-amber-500', 'from-emerald-500');
                btnStart.classList.replace('to-orange-500', 'to-green-600');
            }
        }

        btnReset.addEventListener('click', resetSim);
        btnReset.addEventListener('touchstart', resetSim, {passive: false});

        function resetSim(e) {
            if(e.cancelable) e.preventDefault();
            state.running = false;
            state.time = 0;
            document.getElementById('timerDisplay').textContent = "00.0s";
            
            // Reset Grid
            initGrid();
            
            // Reset Particles
            initParticles();
            
            btnStart.innerHTML = "<span>‚ñ∂</span> Start Heating";
            btnStart.classList.replace('from-amber-500', 'from-emerald-500');
            btnStart.classList.replace('to-orange-500', 'to-green-600');
            flame.style.opacity = 0;
            
            draw();
        }

        heatInput.addEventListener('input', (e) => {
            state.heatPower = parseInt(e.target.value);
            if(state.running) flame.style.opacity = state.heatPower / 100;
        });

        document.querySelectorAll('input[name="viewMode"]').forEach(r => {
            r.addEventListener('change', (e) => {
                state.viewMode = e.target.value;
                // Respawn particles if switching modes for cleaner look
                initParticles(); 
                draw();
            });
        });

        // Touch Interaction
        function handleInteraction(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            
            if (x > 0 && x < canvas.width && y > 0 && y < canvas.height) {
                // Map to grid coordinates
                const c = Math.floor((x / canvas.width) * GRID_COLS);
                const r = Math.floor((y / canvas.height) * GRID_ROWS);
                
                if (state.grid[r] && state.grid[r][c]) {
                    const temp = state.grid[r][c];
                    tooltip.style.display = 'block';
                    tooltip.style.left = x + 'px';
                    tooltip.style.top = (y - 20) + 'px';
                    toolTemp.textContent = temp.toFixed(1);
                    
                    // Dynamic color for temp text
                    const hue = Math.max(0, 240 - (temp - 25) * 3);
                    toolTemp.style.color = `hsl(${hue}, 70%, 50%)`;
                    return true;
                }
            }
            return false;
        }

        canvas.addEventListener('mousemove', (e) => handleInteraction(e.clientX, e.clientY));
        canvas.addEventListener('touchstart', (e) => {
            if(handleInteraction(e.touches[0].clientX, e.touches[0].clientY)) e.preventDefault();
        }, {passive: false});
        canvas.addEventListener('touchmove', (e) => {
            if(handleInteraction(e.touches[0].clientX, e.touches[0].clientY)) e.preventDefault();
        }, {passive: false});
        canvas.addEventListener('touchend', () => tooltip.style.display = 'none');
        canvas.addEventListener('mouseleave', () => tooltip.style.display = 'none');

        // Init
        window.addEventListener('resize', () => { resize(); draw(); });
        resize();
        initGrid();
        initParticles();
        loop();

    </script>
</body>
</html>
